<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Delay coordinates embedding · DelayEmbeddings.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DelayEmbeddings.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">DelayEmbeddings.jl</a></li><li class="is-active"><a class="tocitem" href>Delay coordinates embedding</a><ul class="internal"><li><a class="tocitem" href="#Timeseries-embedding"><span>Timeseries embedding</span></a></li><li><a class="tocitem" href="#Generalized-embeddings"><span>Generalized embeddings</span></a></li><li><a class="tocitem" href="#StateSpaceSet-reference"><span>StateSpaceSet reference</span></a></li></ul></li><li><a class="tocitem" href="../separated/">Separated optimal embedding</a></li><li><a class="tocitem" href="../unified/">Unified optimal embedding</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Delay coordinates embedding</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Delay coordinates embedding</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/main/docs/src/embed.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="embedding"><a class="docs-heading-anchor" href="#embedding">Delay coordinates embedding</a><a id="embedding-1"></a><a class="docs-heading-anchor-permalink" href="#embedding" title="Permalink"></a></h1><p>A timeseries recorded in some manner from a dynamical system can be used to gain information about the dynamics of the entire state space of the system. This can be done by constructing a new state space from the timeseries. One method that can do this is what is known as <a href="https://en.wikipedia.org/wiki/Takens%27_theorem">delay coordinates embedding</a> or delay coordinates reconstruction.</p><p>The main functions to use for embedding some input data are <a href="#DelayEmbeddings.embed"><code>embed</code></a> or <a href="#DelayEmbeddings.genembed"><code>genembed</code></a>. Both functions return a <a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</p><h2 id="Timeseries-embedding"><a class="docs-heading-anchor" href="#Timeseries-embedding">Timeseries embedding</a><a id="Timeseries-embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Timeseries-embedding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.embed" href="#DelayEmbeddings.embed"><code>DelayEmbeddings.embed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">embed(s, d, τ [, h])</code></pre><p>Embed <code>s</code> using delay coordinates with embedding dimension <code>d</code> and delay time <code>τ</code> and return the result as a <a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>. Optionally use weight <code>h</code>, see below.</p><p>Here <code>τ &gt; 0</code>, use <a href="#DelayEmbeddings.genembed"><code>genembed</code></a> for a generalized version.</p><p><strong>Description</strong></p><p>If <code>τ</code> is an integer, then the <span>$n$</span>-th entry of the embedded space is</p><p class="math-container">\[(s(n), s(n+\tau), s(n+2\tau), \dots, s(n+(d-1)\tau))\]</p><p>If instead <code>τ</code> is a vector of integers, so that <code>length(τ) == d-1</code>, then the <span>$n$</span>-th entry is</p><p class="math-container">\[(s(n), s(n+\tau[1]), s(n+\tau[2]), \dots, s(n+\tau[d-1]))\]</p><p>The resulting set can have same invariant quantities (like e.g. Lyapunov exponents) with the original system that the timeseries were recorded from, for proper <code>d</code> and <code>τ</code>. This is known as the Takens embedding theorem <sup class="footnote-reference"><a id="citeref-Takens1981" href="#footnote-Takens1981">[Takens1981]</a></sup> <sup class="footnote-reference"><a id="citeref-Sauer1991" href="#footnote-Sauer1991">[Sauer1991]</a></sup>. The case of different delay times allows embedding systems with many time scales, see<sup class="footnote-reference"><a id="citeref-Judd1998" href="#footnote-Judd1998">[Judd1998]</a></sup>.</p><p>If provided, <code>h</code> can be weights to multiply the entries of the embedded space. If <code>h isa Real</code> then the embedding is</p><p class="math-container">\[(s(n), h \cdot s(n+\tau), h^2 \cdot s(n+2\tau), \dots,h^{d-1} \cdot s(n+γ\tau))\]</p><p>Otherwise <code>h</code> can be a vector of length <code>d-1</code>, which the decides the weights of each entry directly.</p><p><strong>References</strong></p><p><sup class="footnote-reference"><a id="citeref-Takens1981" href="#footnote-Takens1981">[Takens1981]</a></sup> : F. Takens, <em>Detecting Strange Attractors in Turbulence — Dynamical Systems and Turbulence</em>, Lecture Notes in Mathematics <strong>366</strong>, Springer (1981)</p><p><sup class="footnote-reference"><a id="citeref-Sauer1991" href="#footnote-Sauer1991">[Sauer1991]</a></sup> : T. Sauer <em>et al.</em>, J. Stat. Phys. <strong>65</strong>, pp 579 (1991)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/cfe8e88689feb4dda5b17bd0cea4d25777622002/src/embeddings/embed.jl#L67-L111">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Embedding discretized data values</header><div class="admonition-body"><p>If the data values are very strongly discretized (e.g., integers or floating-point numbers with very small bits), this can result to distances between points in the embedded space being 0. This is problematic for several library functions. Best practice here is to add noise to your original timeseries <em>before</em> embedding, e.g., <code>s = s .+ 1e-15randn(length(s))</code>.</p></div></div><hr/><p>Here are some examples of embedding a 3D continuous chaotic system:</p><pre><code class="language-julia hljs">using DelayEmbeddings

x = cos.(0:0.1:1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11-element Vector{Float64}:
 1.0
 0.9950041652780258
 0.9800665778412416
 0.955336489125606
 0.9210609940028851
 0.8775825618903728
 0.8253356149096783
 0.7648421872844885
 0.6967067093471654
 0.6216099682706644
 0.5403023058681398</code></pre><pre><code class="language-julia hljs">embed(x, 3, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-dimensional StateSpaceSet{Float64} with 9 points
 1.0       0.995004  0.980067
 0.995004  0.980067  0.955336
 0.980067  0.955336  0.921061
 0.955336  0.921061  0.877583
 0.921061  0.877583  0.825336
 0.877583  0.825336  0.764842
 0.825336  0.764842  0.696707
 0.764842  0.696707  0.62161
 0.696707  0.62161   0.540302</code></pre><div class="admonition is-info"><header class="admonition-header">`τ` and `Δt`</header><div class="admonition-body"><p>Keep in mind that whether a value of <code>τ</code> is &quot;reasonable&quot; for continuous time systems depends on the sampling time <code>Δt</code>.</p></div></div><h3 id="Embedding-Structs"><a class="docs-heading-anchor" href="#Embedding-Structs">Embedding Structs</a><a id="Embedding-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Embedding-Structs" title="Permalink"></a></h3><p>The high level function <a href="#DelayEmbeddings.embed"><code>embed</code></a> utilizes a low-level interface for creating embedded vectors on-the-fly. The high level interface simply loops over the low level interface.</p><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.DelayEmbedding" href="#DelayEmbeddings.DelayEmbedding"><code>DelayEmbeddings.DelayEmbedding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DelayEmbedding(γ, τ, h = nothing) → `embedding`</code></pre><p>Return a delay coordinates embedding structure to be used as a function-like-object, given a timeseries and some index. Calling</p><pre><code class="language-julia hljs">embedding(s, n)</code></pre><p>will create the <code>n</code>-th delay vector of the embedded space, which has <code>γ</code> temporal neighbors with delay(s) <code>τ</code>. <code>γ</code> is the embedding dimension minus 1, <code>τ</code> is the delay time(s) while <code>h</code> are extra weights, as in <a href="#DelayEmbeddings.embed"><code>embed</code></a> for more.</p><p><strong>Be very careful when choosing <code>n</code>, because <code>@inbounds</code> is used internally.</strong> Use <a href="#DelayEmbeddings.τrange"><code>τrange</code></a>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/cfe8e88689feb4dda5b17bd0cea4d25777622002/src/embeddings/embed.jl#L11-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.τrange" href="#DelayEmbeddings.τrange"><code>DelayEmbeddings.τrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">τrange(s, de::AbstractEmbedding)</code></pre><p>Return the range <code>r</code> of valid indices <code>n</code> to create delay vectors out of <code>s</code> using <code>de</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/cfe8e88689feb4dda5b17bd0cea4d25777622002/src/embeddings/embed.jl#L130-L133">source</a></section></article><h2 id="Generalized-embeddings"><a class="docs-heading-anchor" href="#Generalized-embeddings">Generalized embeddings</a><a id="Generalized-embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-embeddings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.genembed" href="#DelayEmbeddings.genembed"><code>DelayEmbeddings.genembed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genembed(s, τs, js = ones(...); ws = nothing) → ssset</code></pre><p>Create a generalized embedding of <code>s</code> which can be a timeseries or arbitrary <code>StateSpaceSet</code>, and return the result as a new <code>StateSpaceSet</code>.</p><p>The generalized embedding works as follows:</p><ul><li><code>τs</code> denotes what delay times will be used for each of the entries of the delay vector. It is recommended that <code>τs[1] = 0</code>. <code>τs</code> is allowed to have <em>negative entries</em> as well.</li><li><code>js</code> denotes which of the timeseries contained in <code>s</code> will be used for the entries of the delay vector. <code>js</code> can contain duplicate indices.</li><li><code>ws</code> are optional weights that weight each embedded entry (the i-th entry of the   delay vector is weighted by <code>ws[i]</code>). If provided, it is recommended that <code>ws[1] == 1</code>.</li></ul><p><code>τs, js, ws</code> are tuples (or vectors) of length <code>D</code>, which also coincides with the embedding dimension. For example, imagine input trajectory <span>$s = [x, y, z]$</span> where <span>$x, y, z$</span> are timeseries (the columns of the <code>StateSpaceSet</code>). If <code>js = (1, 3, 2)</code> and <code>τs = (0, 2, -7)</code> the created delay vector at each step <span>$n$</span> will be</p><p class="math-container">\[(x(n), z(n+2), y(n-7))\]</p><p>Using <code>ws = (1, 0.5, 0.25)</code> as well would create</p><p class="math-container">\[(x(n), \frac{1}{2} z(n+2), \frac{1}{4} y(n-7))\]</p><p><code>js</code> can be skipped, defaulting to index 1 (first timeseries) for all delay entries, while it has no effect if <code>s</code> is a timeseries instead of a <code>StateSpaceSet</code>.</p><p>See also <a href="#DelayEmbeddings.embed"><code>embed</code></a>. Internally uses <a href="#DelayEmbeddings.GeneralizedEmbedding"><code>GeneralizedEmbedding</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/cfe8e88689feb4dda5b17bd0cea4d25777622002/src/embeddings/genembed.jl#L85-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.GeneralizedEmbedding" href="#DelayEmbeddings.GeneralizedEmbedding"><code>DelayEmbeddings.GeneralizedEmbedding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedEmbedding(τs, js = ones(length(τs)), ws = nothing) -&gt; `embedding`</code></pre><p>Return a delay coordinates embedding structure to be used as a function. Given a timeseries <em>or</em> trajectory (i.e. <code>StateSpaceSet</code>) <code>s</code> and calling</p><pre><code class="language-julia hljs">embedding(s, n)</code></pre><p>will create the delay vector of the <code>n</code>-th point of <code>s</code> in the embedded space using generalized embedding (see <a href="#DelayEmbeddings.genembed"><code>genembed</code></a>).</p><p><code>js</code> is ignored for timeseries input <code>s</code> (since all entries of <code>js</code> must be <code>1</code> in this case) and in addition <code>js</code> defaults to <code>(1, ..., 1)</code> for all <code>τ</code>.</p><p><strong>Be very careful when choosing <code>n</code>, because <code>@inbounds</code> is used internally.</strong> Use <a href="#DelayEmbeddings.τrange"><code>τrange</code></a>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/cfe8e88689feb4dda5b17bd0cea4d25777622002/src/embeddings/genembed.jl#L6-L22">source</a></section></article><h2 id="StateSpaceSet-reference"><a class="docs-heading-anchor" href="#StateSpaceSet-reference">StateSpaceSet reference</a><a id="StateSpaceSet-reference-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.StateSpaceSet" href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StateSpaceSet{D, T} &lt;: AbstractStateSpaceSet{D,T}</code></pre><p>A dedicated interface for sets in a state space. It is an <strong>ordered container of equally-sized points</strong> of length <code>D</code>. Each point is represented by <code>SVector{D, T}</code>. The data are a standard Julia <code>Vector{SVector}</code>, and can be obtained with <code>vec(ssset::StateSpaceSet)</code>. Typically the order of points in the set is the time direction, but it doesn&#39;t have to be.</p><p>When indexed with 1 index, <code>StateSpaceSet</code> is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.</p><p><code>StateSpaceSet</code> also supports almost all sensible vector operations like <code>append!, push!, hcat, eachrow</code>, among others.</p><p><strong>Description of indexing</strong></p><p>In the following let <code>i, j</code> be integers, <code>typeof(X) &lt;: AbstractStateSpaceSet</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for performance benefits make <code>v2</code> an <code>SVector{Int}</code>).</p><ul><li><code>X[i] == X[i, :]</code> gives the <code>i</code>th point (returns an <code>SVector</code>)</li><li><code>X[v1] == X[v1, :]</code>, returns a <code>StateSpaceSet</code> with the points in those indices.</li><li><code>X[:, j]</code> gives the <code>j</code>th variable timeseries (or collection), as <code>Vector</code></li><li><code>X[v1, v2], X[:, v2]</code> returns a <code>StateSpaceSet</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>X[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(ssset)</code> or <code>StateSpaceSet(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>StateSpaceSet(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Judd1998"><a class="tag is-link" href="#citeref-Judd1998">Judd1998</a>K. Judd &amp; A. Mees, <a href="https://www.sciencedirect.com/science/article/pii/S0167278997001188">Physica D <strong>120</strong>, pp 273 (1998)</a></li><li class="footnote" id="footnote-Farmer1988"><a class="tag is-link" href="#citeref-Farmer1988">Farmer1988</a>Farmer &amp; Sidorowich, <a href="http://www.nzdl.org/gsdlmod?e=d-00000-00---off-0cltbibZz-e--00-1----0-10-0---0---0direct-10---4-------0-1l--11-en-50---20-home---00-3-1-00-0--4--0--0-0-11-10-0utfZz-8-00&amp;a=d&amp;cl=CL3.16&amp;d=HASH013b29ffe107dba1e52f1a0c_1245">Exploiting Chaos to Predict the Future and Reduce Noise&quot;</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« DelayEmbeddings.jl</a><a class="docs-footer-nextpage" href="../separated/">Separated optimal embedding »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 20 October 2023 12:50">Friday 20 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
