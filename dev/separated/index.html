<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Separated optimal embedding ¬∑ DelayEmbeddings.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DelayEmbeddings.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">DelayEmbeddings.jl</a></li><li><a class="tocitem" href="../embed/">Delay coordinates embedding</a></li><li class="is-active"><a class="tocitem" href>Separated optimal embedding</a><ul class="internal"><li><a class="tocitem" href="#Automated-function"><span>Automated function</span></a></li><li><a class="tocitem" href="#Optimal-delay-time"><span>Optimal delay time</span></a></li><li><a class="tocitem" href="#Optimal-embedding-dimension"><span>Optimal embedding dimension</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../unified/">Unified optimal embedding</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Separated optimal embedding</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Separated optimal embedding</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/main/docs/src/separated.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Separated-optimal-embedding"><a class="docs-heading-anchor" href="#Separated-optimal-embedding">Separated optimal embedding</a><a id="Separated-optimal-embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Separated-optimal-embedding" title="Permalink"></a></h1><p>This page discusses and provides algorithms for estimating optimal parameters to do Delay Coordinates Embedding (DCE) with using the separated approach.</p><h2 id="Automated-function"><a class="docs-heading-anchor" href="#Automated-function">Automated function</a><a id="Automated-function-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.optimal_separated_de" href="#DelayEmbeddings.optimal_separated_de"><code>DelayEmbeddings.optimal_separated_de</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimal_separated_de(s, method = &quot;afnn&quot;, dmethod = &quot;mi_min&quot;; kwargs...) ‚Üí ùíü, œÑ, E</code></pre><p>Produce an optimal delay embedding <code>ùíü</code> of the given timeseries <code>s</code> by using the <em>separated</em> approach of first finding an optimal (and constant) delay time using <a href="#DelayEmbeddings.estimate_delay"><code>estimate_delay</code></a> with the given <code>dmethod</code>, and then an optimal embedding dimension, by calculating an appropriate statistic for each dimension <code>d ‚àà 1:dmax</code>. Return the embedding <code>ùíü</code>, the optimal delay time <code>œÑ</code> (the optimal embedding dimension <code>d</code> is just <code>size(ùíü, 2)</code>) and the actual statistic <code>E</code> used to estimate optimal <code>d</code>.</p><p>Notice that <code>E</code> is a function of the embedding dimension, which ranges from 1 to <code>dmax</code>.</p><p>For calculating <code>E</code> to estimate the dimension we use the given <code>method</code> which can be:</p><ul><li><code>&quot;afnn&quot;</code> (default) is Cao&#39;s &quot;Averaged False Nearest Neighbors&quot; method<sup class="footnote-reference"><a id="citeref-Cao1997" href="#footnote-Cao1997">[Cao1997]</a></sup>,   which gives a ratio of distances between nearest neighbors.</li><li><code>&quot;ifnn&quot;</code> is the &quot;Improved False Nearest Neighbors&quot; from Hegger &amp; Kantz<sup class="footnote-reference"><a id="citeref-Hegger1999" href="#footnote-Hegger1999">[Hegger1999]</a></sup>,   which gives the fraction of false nearest neighbors.</li><li><code>&quot;fnn&quot;</code> is Kennel&#39;s &quot;False Nearest Neighbors&quot; method<sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup>, which gives   the number of points that cease to be &quot;nearest neighbors&quot; when the dimension   increases.</li><li><code>&quot;f1nn&quot;</code> is Krakovsk√°&#39;s &quot;False First Nearest Neighbors&quot; method<sup class="footnote-reference"><a id="citeref-Krakovsk√°2015" href="#footnote-Krakovsk√°2015">[Krakovsk√°2015]</a></sup>,   which gives the ratio of pairs of points that cease to be &quot;nearest neighbors&quot;   when the dimension increases.</li></ul><p>For more details, see individual methods: <a href="#DelayEmbeddings.delay_afnn"><code>delay_afnn</code></a>, <a href="#DelayEmbeddings.delay_ifnn"><code>delay_ifnn</code></a>, <a href="#DelayEmbeddings.delay_fnn"><code>delay_fnn</code></a>, <a href="#DelayEmbeddings.delay_f1nn"><code>delay_f1nn</code></a>.</p><div class="admonition is-category-warn"><header class="admonition-header">Careful in automated methods</header><div class="admonition-body"><p>While this method is automated if you want to be <strong>really sure</strong> of the results, you should directly calculate the statistic and plot its values versus the dimensions.</p></div></div><p><strong>Keyword arguments</strong></p><p>The keywords</p><pre><code class="language-julia hljs">œÑs = 1:100, dmax = 10</code></pre><p>denote which delay times and embedding dimensions <code>ds ‚àà 1:dmax</code> to consider when calculating optimal embedding. The keywords</p><pre><code class="language-julia hljs">slope_thres = 0.05, stoch_thres = 0.1, fnn_thres = 0.05</code></pre><p>are specific to this function, see Description below. All remaining keywords are propagated to the low level functions:</p><pre><code class="nohighlight hljs">w, rtol, atol, œÑs, metric, r</code></pre><p><strong>Description</strong></p><p>We estimate the optimal embedding dimension based on the given delay time gained from <code>dmethod</code> as follows: For Cao&#39;s method the optimal dimension is reached, when the slope of the <code>E‚ÇÅ</code>-statistic (output from <code>&quot;afnn&quot;</code>) falls below the threshold <code>slope_thres</code> and the according stochastic test turns out to be false, i.e. if the <code>E‚ÇÇ</code>-statistic&#39;s first value is <code>&lt; 1 - stoch_thres</code>.</p><p>For all the other methods we return the optimal embedding dimension when the corresponding FNN-statistic (output from <code>&quot;ifnn&quot;</code>, <code>&quot;fnn&quot;</code> or <code>&quot;f1nn&quot;</code>) falls below the fnn-threshold <code>fnn_thres</code> AND the slope of the statistic falls below the threshold <code>slope_thres</code>. Note that with noise contaminated time series, one might need to adjust <code>fnn_thres</code> according to the noise level.</p><p>See also the file <code>test/compare_different_dimension_estimations.jl</code> for a comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/automated.jl#L3-L78">source</a></section></article><h2 id="Optimal-delay-time"><a class="docs-heading-anchor" href="#Optimal-delay-time">Optimal delay time</a><a id="Optimal-delay-time-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-delay-time" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.estimate_delay" href="#DelayEmbeddings.estimate_delay"><code>DelayEmbeddings.estimate_delay</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_delay(s, method::String [, œÑs = 1:100]; kwargs...) -&gt; œÑ</code></pre><p>Estimate an optimal delay to be used in <a href="../embed/#DelayEmbeddings.embed"><code>embed</code></a>. The <code>method</code> can be one of the following:</p><ul><li><code>&quot;ac_zero&quot;</code> : first delay at which the auto-correlation function becomes &lt;0.</li><li><code>&quot;ac_min&quot;</code> : delay of first minimum of the auto-correlation function.</li><li><code>&quot;mi_min&quot;</code> : delay of first minimum of mutual information of <code>s</code> with itself (shifted for various <code>œÑs</code>). Keywords <code>nbins, binwidth</code> are propagated into <a href="#DelayEmbeddings.selfmutualinfo"><code>selfmutualinfo</code></a>.</li><li><code>&quot;exp_decay&quot;</code> : <a href="#DelayEmbeddings.exponential_decay_fit"><code>exponential_decay_fit</code></a> of the correlation function rounded  to an integer (uses least squares on <code>c(t) = exp(-t/œÑ)</code> to find <code>œÑ</code>).</li><li><code>&quot;exp_extrema&quot;</code> : same as above but the exponential fit is done to the absolute value of the local extrema of the correlation function.</li></ul><p>Both the mutual information and correlation function (<code>autocor</code>) are computed <em>only</em> for delays <code>œÑs</code>. This means that the <code>min</code> methods can never return the first value of <code>œÑs</code>!</p><p>The method <code>mi_min</code> is significantly more accurate than the others and also returns good results for most timeseries. It is however the slowest method (but still quite fast!).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_delay.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.exponential_decay_fit" href="#DelayEmbeddings.exponential_decay_fit"><code>DelayEmbeddings.exponential_decay_fit</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exponential_decay_fit(x, y, weight = :equal) -&gt; œÑ</code></pre><p>Perform a least square fit of the form <code>y = exp(-x/œÑ)</code> and return <code>œÑ</code>. Taken from:  http://mathworld.wolfram.com/LeastSquaresFittingExponential.html. Assumes equal lengths of <code>x, y</code> and that <code>y ‚â• 0</code>.</p><p>To use the method that gives more weight to small values of <code>y</code>, use <code>weight = :small</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_delay.jl#L89-L96">source</a></section></article><h3 id="Self-Mutual-Information"><a class="docs-heading-anchor" href="#Self-Mutual-Information">Self Mutual Information</a><a id="Self-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Self-Mutual-Information" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.selfmutualinfo" href="#DelayEmbeddings.selfmutualinfo"><code>DelayEmbeddings.selfmutualinfo</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selfmutualinfo(s, œÑs; kwargs...) ‚Üí m</code></pre><p>Calculate the mutual information between the time series <code>s</code> and itself delayed by <code>œÑ</code> points for <code>œÑ</code> ‚àà <code>œÑs</code>, using an <em>improvement</em> of the method outlined by Fraser &amp; Swinney in<sup class="footnote-reference"><a id="citeref-Fraser1986" href="#footnote-Fraser1986">[Fraser1986]</a></sup>.</p><p><strong>Description</strong></p><p>The joint space of <code>s</code> and its <code>œÑ</code>-delayed image (<code>sœÑ</code>) is partitioned as a rectangular grid, and the mutual information is computed from the joint and marginal frequencies of <code>s</code> and <code>sœÑ</code> in the grid as defined in [1]. The mutual information values are returned in a vector <code>m</code> of the same length as <code>œÑs</code>.</p><p>If any of the optional keyword parameters is given, the grid will be a homogeneous partition of the space where <code>s</code> and <code>sœÑ</code> are defined. The margins of that partition will be divided in a number of bins equal to <code>nbins</code>, such that the width of each bin will be <code>binwidth</code>, and the range of nonzero values of <code>s</code> will be in the centre. If only of those two parameters is given, the other will be automatically calculated to adjust the size of the grid to the area where <code>s</code> and <code>sœÑ</code> are nonzero.</p><p>If no parameter is given, the space will be partitioned by a recursive bisection algorithm based on the method given in [1].</p><p>Notice that the recursive method of [1] evaluates the joint frequencies of <code>s</code> and <code>sœÑ</code> in each cell resulting from a partition, and stops when the data points are uniformly distributed across the sub-partitions of the following levels. For performance and stability reasons, the automatic partition method implemented in this function is only used to divide the axes of the grid, using the marginal frequencies of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_delay.jl#L124-L158">source</a></section></article><p>Notice that mutual information between two <em>different</em> timeseries x, y exists in JuliaDynamics as well, but in the package <a href="https://github.com/JuliaDynamics/CausalityTools.jl">CausalityTools.jl</a>. It is also trivial to define it yourself using <code>entropy</code> from <code>ComplexityMeasures</code>.</p><h2 id="Optimal-embedding-dimension"><a class="docs-heading-anchor" href="#Optimal-embedding-dimension">Optimal embedding dimension</a><a id="Optimal-embedding-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-embedding-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_afnn" href="#DelayEmbeddings.delay_afnn"><code>DelayEmbeddings.delay_afnn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delay_afnn(s::AbstractVector, œÑ:Int, ds = 2:6; metric=Euclidean(), w = 0) ‚Üí E‚ÇÅ</code></pre><p>Compute the parameter E‚ÇÅ of Cao&#39;s &quot;averaged false nearest neighbors&quot; method for determining the minimum embedding dimension of the time series <code>s</code>, with a sequence of <code>œÑ</code>-delayed temporal neighbors.</p><p><strong>Description</strong></p><p>Given the scalar timeseries <code>s</code> and the embedding delay <code>œÑ</code> compute the values of <code>E‚ÇÅ</code> for each embedding dimension <code>d ‚àà ds</code>, according to Cao&#39;s Method (eq. 3 of<sup class="footnote-reference"><a id="citeref-Cao1997" href="#footnote-Cao1997">[Cao1997]</a></sup>).</p><p>This quantity is a ratio of the averaged distances between the nearest neighbors of the reconstructed time series, which quantifies the increment of those distances when the embedding dimension changes from <code>d</code> to <code>d+1</code>.</p><p>Return the vector of all computed <code>E‚ÇÅ</code>s. To estimate a good value for <code>d</code> from this, find <code>d</code> for which the value <code>E‚ÇÅ</code> saturates at some value around 1.</p><p><em>Note: This method does not work for datasets with perfectly periodic signals.</em></p><p><code>w</code> is the <a href="@ref">Theiler window</a>.</p><p>See also: <a href="#DelayEmbeddings.optimal_separated_de"><code>optimal_separated_de</code></a> and <a href="#DelayEmbeddings.stochastic_indicator"><code>stochastic_indicator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_dimension.jl#L16-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_ifnn" href="#DelayEmbeddings.delay_ifnn"><code>DelayEmbeddings.delay_ifnn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delay_ifnn(s::Vector, œÑ::Int, ds = 1:10; kwargs...) ‚Üí `FNNs`</code></pre><p>Compute and return the <code>FNNs</code>-statistic for the time series <code>s</code> and a uniform time delay <code>œÑ</code> and embedding dimensions <code>ds</code> after <sup class="footnote-reference"><a id="citeref-Hegger1999" href="#footnote-Hegger1999">[Hegger1999]</a></sup>. In this notation <code>Œ≥ ‚àà Œ≥s = d-1</code>, if <code>d</code> is the embedding dimension. This fraction tends to 0 when the optimal embedding dimension with an appropriate lag is reached.</p><p><strong>Keywords</strong></p><p>*<code>r = 2</code>: Obligatory threshold, which determines the maximum tolerable spreading     of trajectories in the reconstruction space. *<code>metric = Euclidean</code>: The norm used for distance computations. *<code>w = 1</code> = The <a href="@ref">Theiler window</a>.</p><p>See also: <a href="#DelayEmbeddings.optimal_separated_de"><code>optimal_separated_de</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_dimension.jl#L251-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_fnn" href="#DelayEmbeddings.delay_fnn"><code>DelayEmbeddings.delay_fnn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delay_fnn(s::AbstractVector, œÑ:Int, ds = 2:6; rtol=10.0, atol=2.0) ‚Üí FNNs</code></pre><p>Calculate the number of &quot;false nearest neighbors&quot; (FNNs) of the datasets created from <code>s</code> with <code>embed(s, d, œÑ) for d ‚àà ds</code>.</p><p><strong>Description</strong></p><p>Given a dataset made by <code>embed(s, d, œÑ)</code> the &quot;false nearest neighbors&quot; (FNN) are the pairs of points that are nearest to each other at dimension <code>d</code>, but are separated at dimension <code>d+1</code>. Kennel&#39;s criteria for detecting FNN are based on a threshold for the relative increment of the distance between the nearest neighbors (<code>rtol</code>, eq. 4 in<sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup>), and another threshold for the ratio between the increased distance and the &quot;size of the attractor&quot; (<code>atol</code>, eq. 5 in<sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup>). These thresholds are given as keyword arguments.</p><p>The returned value is a vector with the number of FNN for each <code>Œ≥ ‚àà Œ≥s</code>. The optimal value for <code>Œ≥</code> is found at the point where the number of FNN approaches zero.</p><p>See also: <a href="#DelayEmbeddings.optimal_separated_de"><code>optimal_separated_de</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_dimension.jl#L136-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_f1nn" href="#DelayEmbeddings.delay_f1nn"><code>DelayEmbeddings.delay_f1nn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delay_f1nn(s::AbstractVector, œÑ::Int, ds = 2:6; metric = Euclidean())</code></pre><p>Calculate the ratio of &quot;false first nearest neighbors&quot; (FFNN) of the datasets created from <code>s</code> with <code>embed(s, d, œÑ) for d ‚àà ds</code>.</p><p><strong>Description</strong></p><p>Given a dataset made by <code>embed(s, d, œÑ)</code> the &quot;false first nearest neighbors&quot; (FFNN) are the pairs of points that are nearest to each other at dimension <code>d</code> that cease to be nearest neighbors at dimension <code>d+1</code>.</p><p>The returned value is a vector with the ratio between the number of FFNN and the number of points in the dataset for each <code>d ‚àà ds</code>. The optimal value for <code>d</code> is found at the point where this ratio approaches zero.</p><p>See also: <a href="#DelayEmbeddings.optimal_separated_de"><code>optimal_separated_de</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_dimension.jl#L188-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.stochastic_indicator" href="#DelayEmbeddings.stochastic_indicator"><code>DelayEmbeddings.stochastic_indicator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stochastic_indicator(s::AbstractVector, œÑ:Int, ds = 2:5) -&gt; E‚ÇÇs</code></pre><p>Compute an estimator for apparent randomness in a delay embedding with <code>ds</code> dimensions.</p><p><strong>Description</strong></p><p>Given the scalar timeseries <code>s</code> and the embedding delay <code>œÑ</code> compute the values of <code>E‚ÇÇ</code> for each <code>d ‚àà ds</code>, according to Cao&#39;s Method (eq. 5 of <sup class="footnote-reference"><a id="citeref-Cao1997" href="#footnote-Cao1997">[Cao1997]</a></sup>).</p><p>Use this function to confirm that the input signal is not random and validate the results of <a href="#DelayEmbeddings.delay_afnn"><code>delay_afnn</code></a>. In the case of random signals, it should be <code>E‚ÇÇ ‚âà 1 ‚àÄ d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DelayEmbeddings.jl/blob/9a0bbfe277c0eb809221a278710b4fca2e11f738/src/separated_de/estimate_dimension.jl#L91-L103">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><pre><code class="language- hljs">using DelayEmbeddings, CairoMakie
using DynamicalSystemsBase

function roessler_rule(u, p, t)
    a, b, c = p
    du1 = -u[2]-u[3]
    du2 = u[1] + a*u[2]
    du3 = b + u[3]*(u[1] - c)
    return SVector(du1, du2, du3)
end
ds = CoupledODEs(roessler_rule, [1, -2, 0.1], [0.2, 0.2, 5.7])

# This trajectory is a chaotic attractor with fractal dim ‚âà 2
# therefore the set needs at least embedding dimension of 3
X, tvec = trajectory(ds, 1000.0; Œît = 0.05)
x = X[:, 1]

dmax = 7
fig = Figure()
ax = Axis(fig[1,1]; xlabel = &quot;embedding dimension&quot;, ylabel = &quot;estimator&quot;)
for (i, method) in enumerate([&quot;afnn&quot;, &quot;fnn&quot;, &quot;f1nn&quot;, &quot;ifnn&quot;])
    # Plot statistic used to estimate optimal embedding
    # as well as the automated output embedding
    ùíü, œÑ, E = optimal_separated_de(x, method; dmax)
    lines!(ax, 1:dmax, E; label = method, marker = :circle, color = Cycled(i))
    optimal_d = size(ùíü, 2)
    ## Scatter the optimal embedding dimension as a lager marker
    scatter!(ax, [optimal_d], [E[optimal_d]];
        color = Cycled(i), markersize = 30
    )
end
axislegend(ax)
fig</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Cao1997"><a class="tag is-link" href="#citeref-Cao1997">Cao1997</a>Liangyue Cao, <a href="https://www.sciencedirect.com/science/article/pii/S0167278997001188?via%3Dihub">Physica D, pp. 43-50 (1997)</a></li><li class="footnote" id="footnote-Kennel1992"><a class="tag is-link" href="#citeref-Kennel1992">Kennel1992</a>M. Kennel <em>et al.</em>, <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.45.3403">Phys. Review A <strong>45</strong>(6), (1992)</a>.</li><li class="footnote" id="footnote-Krakovsk√°2015"><a class="tag is-link" href="#citeref-Krakovsk√°2015">Krakovsk√°2015</a>Anna Krakovsk√° <em>et al.</em>, <a href="https://doi.org/10.1155/2015/932750">J. Complex Sys. 932750 (2015)</a></li><li class="footnote" id="footnote-Hegger1999"><a class="tag is-link" href="#citeref-Hegger1999">Hegger1999</a>Hegger &amp; Kantz, <a href="https://doi.org/10.1103/PhysRevE.60.4970">Improved false nearest neighbor method to detect determinism in time series data. Physical Review E 60, 4970</a>.</li><li class="footnote" id="footnote-Fraser1986"><a class="tag is-link" href="#citeref-Fraser1986">Fraser1986</a>Fraser A.M. &amp; Swinney H.L. &quot;Independent coordinates for strange attractors from mutual information&quot; <em>Phys. Rev. A 33</em>(2), 1986, 1134:1140.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../embed/">¬´ Delay coordinates embedding</a><a class="docs-footer-nextpage" href="../unified/">Unified optimal embedding ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 5 September 2023 21:27">Tuesday 5 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
